# 스레드 상태 제어
- 실행 중인 스레드의 상태를 변경하는 것

**멀티 스레드 프로그램을 만들기 위해서는 정교한 스레드 상태 제어가 필요한데, 상태 제어가 잘못되면
프로그램은 불안정해져서 먹통이 되거나 다운된다. 스레드 제어를 제대로 하기 위해서는
스레드의 상태 변화를 가져오는 메소드들을 파악하고 있어야 한다.**
## 주어진 시간동안 일시 정지 (sleep())
- Thread.sleep() 메소드를 호출한 스레드는 주어진 시간 동안 일시 정지 상태가 되고, 다시 실행 대기 상태로 돌아간다.
```aidl
try {
    Thread.sleep(1000);
} catch(InterruptedException e) {
    // interrupt() 메소드가 호출되면 실행
}
```
## 다른 스레드에게 실행 양보 (yield())
- run() 메소드가 무의미한 반복을 할 때 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로
가는 것이 전체 프로그램 성능에 도움이 된다.
  - yield() 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른
    스레드가 실행 기회를 가질 수 있도록 해준다.
## 다른 스레드의 종료를 기다림 (join())
- 스레드는 다른 스레드와 독립적으로 실행하는 것이 기본이지만 다른 스레드가 종료될 때까지 기다렸다가 실행
해야하는 경우가 발생할 수도 있다.
## 스레드 간 협업(wait(), notify(), notifyAll())
- 경우에 따라서는 두 개의 스레드를 교대로 번갈아가며 실행해야 할 경우가 있다.
## 스레드의 안전한 종료 (stop 플래그, interrupt())
- Thread는 스레드를 즉시 종료시키기 위해서 stop() 메소드를 제공하고 있는데, 이 메소드는 deprecated되었다.
그 이유는 stop() 메소드로 스레드를 갑자기 종료하게 되면 스레드가 사용 중이던 자원들이 불안전한 상태로 남겨지기 때문이다.
### stop 플래그를 이용하는 방법
- 스레드는 run() 메소드가 끝나면 자동적으로 종료되므로, run() 메소드가 정상적으로 종료되도록 유도하는 것이
최선의 방법이다. 
  - stop() 메소드로 스레드를 종료하면 남아있는 자원들을 정리하지 못하지만 stop 플래그를 사용하면 남아있는 자원들을 정리할 수 있다.
  ```aidl
  public class XXXThread extends Thread {
     private boolean stop; // stop 플래그 필드
  
     public void run() {
       while(!stop) {
         스레드가 반복 실행하는 코드;
       }
     }
  }
  ```
### interrupt() 메소드를 이용하는 방법
- interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptedException 예외를
발생시키는 역할을 한다. 이것을 이용하면 run() 메소드를 정상 종료시킬 수 있다.
  - 예를 들어 ThreadA가 ThreadB를 생성해서 start() 메소드로 ThreadB를 실행했다고 가정해보자. 
  ThreadA가 ThreadB의 interrupt() 메소드를 실행하게 되면 ThreadB가 sleep() 메소드로 일시 정지 상태가
    될 때 ThreadB에서 InterruptedException이 발생하여 예외처리 블록으로 이동한다. 그곳에서
    자원을 정리하고 run() 메소드는 종료된다.
  - 스레드가 실행 대기 또는 실행 상태에 있을 때 interrupt() 메소드가 실행되면 즉시 InterruptedException
  예외가 발생하지 않고, 스레드가 미래에 일시 정지 상태가 되면 InterruptedException 예외가 발생한다.