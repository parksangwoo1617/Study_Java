# 람다식이란?
- 익명 함수를 생성하기 위한 식으로 객체 지향 언어보다는 함수 지향 언어에 가깝다.
- 자바 코드가 매우 간결해지고, 컬렉션의 요소를 필터링하거나 매핑해서 원하는 결과를 쉽게 집계할 수 있다는 장점이 있다.
- 람다식의 형태는 매개 변수를 가진 코드 블록이지만, 런타임 시에는 익명 구현 객체를 생성한다.
    - ```(매개변수) -> { 실행코드 }```
# 람다식 기본 문법
```(타입 매개변수, ...) -> { 실행문; }```
- 타입 매개변수: 오른쪽 중괄호 { } 블록을 실행하기 위해 필요한 값을 제공하는 역할
- ->: 매개 변수를 이용해서 중괄호 { }를 실행
  - ex) ```(a) -> { System.out.println(a); }```
  - 매개 변수 타입은 런타임 시에 대입되는 값에 따라 자동으로 인식될 수 있기 때문에 람다식에서는 매개 변수의 타입을 
  일반적으로 언급하지 않는다.
    - 하나의 매개 변수만 있다면 괄호 ()를 생략할 수 있고, 하나의 실행문만 있다면 중괄호 {}도 생략할 수 있다.
      - ```a -> System.out.println(a)```
  
# 타겟 타입과 함수적 인터페이스
- 람다식은 인터페이스 변수에 대입된다. 인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스가 필요한데, 람다식은 익명 구현 클래스를 생성하고 객체화한다.
람다식은 대입될 인터페이스의 종류에 따라 작성방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 타겟타입이라고 한다.
  
## 함수적 인터페이스 (@FunctionalInterface)
- 람다식이 하나의 메소드를 정의하기 때문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없다.
하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데, 이러한 인터페이스를 함수적 인터페이스라고 한다.
  
- @FunctionalInterface <- 함수적 인터페이스를 작성할 때 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주도록하는 어노테이션
```aidl
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
    public void otherMethod();  // 컴파일 오류
}
```
## 매개 변수와 리턴값이 없는 람다식
- 매개 변수와 리턴값이 없는 추상 메소드를 가진 함수적 인터페이스가 있을 때,
이 인터페이스를 타겟 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야한다. 
  ```MyFunctionalInterface fi = () -> { ... }```
  
- 람다식이 대입된 인터페이스의 참조 변수는 다음과 같이 method() 를 호출할 수 있다.
```fi.method();```
  
## 매개 변수가 있는 람다식
- 매개 변수가 있고 리턴값이 없는 추상 메소드를 가진 함수적 인터페이스가 있을 때,
이 인터페이스를 타겟 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야한다.
  ```MyFunctionalInterface fi = (x) -> { ... } 또는 x -> { ... }```
  
## 리턴값이 있는 람다식
- 매개 변수와 리턴 값이 둘 다 있는 추상 메소드를 가진 함수적 인터페이스가 있을 때,
이 인터페이스를 타겟 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야한다.
  ```MyFunctionalInterface fi = (x, y) -> { ...; return 값; }```
  - 중괄호에 return 문만 있다면 중괄호를 생략하고 사용해도 된다.
  
## 클래스 멤버와 로컬 변수 사용
- 람다식의 실행 블록에는 클래스의 멤버 및 로컬 변수를 사용할 수 있다. 단, 클래스의 멤버는 제약 사항 없이 사용 가능하지만,
로컬 변수는 제약 사항이 따른다.
  
### 클래스의 멤버 사용
- 일반적으로 익명 객체 내부에서 this는 익명 객체의 참조이지만, 람다식에서 this는 내부적으로 생성되는 익명 객체의 참조가 아니라
람다식을 실행한 객체의 참조이다.
  
### 로컬 변수 사용
- 람다식은 메소드 내부에서 주로 작성되기 때문에 로컬 익명 구현 객체를 생성시킨다고 봐야 한다.
람다식에서 바깥 클래스의 필드나 메소드는 제한 없이 사용할 수 있으나, 메소드의 매개 변수 또는 로컬 변수를
  사용하면 이 두 변수는 final 특성을 가져야 한다.
  
## 표준 API의 함수적 인터페이스
- 자바에서 제공되는 표준 API에서 한 개의 추상 메소드를 가지는 인터페이스들은 모두 람다식을 이용해서
익명 구현 객체로 표현이 가능하다. 예를 들어 스레드의 작업을 정의하는 Runnable 인터페이스는 매개 변수와
  리턴값이 없는 run() 메소드만 존재하기 때문에 람다식을 이용해서 Runnable 인스턴스를 생성시킬 수 있다.
  
- 자바 8부터는 빈번하게 사용되는 함수적 인터페이스는 java.util.function 표준 API 패키지로 제공한다.
### Consumer 함수적 인터페이스
- 리턴값이 없는 accept() 메소드를 가지고 있다. 단지 매개값을 소비하는 역할만 한다.
- Consumer<T> 인터페이스를 타겟 타입으로 하는 람다식은 다음과 같이 작성할 수 있다.
```Consumer<String> consumer = t -> { t를 소비하는 실행문; };```
  
- BiConsumer<T, U> 인터페이스를 타겟 타입으로 하는 람다식은 다음과 같이 작성할 수 있다.
```BiConsumer<String, String> consumer = (t, u) -> { t와 u를 소비하는 실행문; }```
  
### Supplier 함수적 인터페이스
- 매개 변수가 없고 리턴값이 있는 getXXX() 메소드를 가지고 있다. 실행 후 호출한 곳으로 데이터를 리턴하는 역할을 한다.
- Supplier<T> 인터페이스를 타겟 타입으로 하는 람다식은 다음과 같이 작성할 수 있다.
```Supplier<String> supplier = () -> { ...; return "문자열"; }```
- T가 String 타입이므로 람다식의 중괄호는 문자열을 리턴하도록 해야한다.
### Function 함수적 인터페이스
- 매개값과 리턴값이 있는 applyXXX() 메소드를 가지고 있다.
- 매개값을 리턴값으로 매핑(타입 변환)하는 역할을 한다.
- Function<T, R> 인터페이스를 타겟 타입으로 하는 람다식은 다음과 같이 작성할 수 있다.
```
Function<Student, String> function = t -> { return t.getName(); }
또는
Function<Student, String> function = t -> t.getName();
```
- T가 Student 타입이고 R이 String 타입이므로 t 매개변수 타입은 Student가 되고, 람다식의 중괄호는 String을 리턴해야한다.
 
### Operator 함수적 인터페이스
- 매개 변수와 리턴값이 있는 applyXXX() 메소드를 가지고 있다.
- 리턴값으로 매핑하는 역할 보다는 매개값을 이용해서 연산을 수행한 후 동일한 타입으로 리턴값을 제공하는 역할을 한다.
- InBinaryOperator 인터페이스를 타겟 타입으로 하는 람다식은 다음과 같이 작성할 수 있다.
```IntBinaryOperator operator = (a, b) -> { ...; return int값; }```
  
### Predicate 함수적 인터페이스
- 매개 변수와 boolean 리턴값이 있는 testXXX() 메소드를 가지고 있다.
- 매개값을 조사해서 true 또는 false를 리턴하는 역할을 한다.
- Predicate<T> 인터페이스를 타겟 타입으로 하는 람다식은 다음과 같이 작성할 수 있다.
```
Predicate<Student> predicate = t -> { return t.getSex().equals("남자"); }
또는
Predicate<Student> predicate = t -> t.getSex().equals("남자");
```
## 메소드 참조
- 메소드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개 변수를 제거하는 것이 목적이다.
- 예를 들어 두 개의 값을 받아 큰 수를 리턴하는 Math 클래스의 max() 정적 메소드를 호출하는 람다식은 다음과 같다.
```(left, right) -> Math.max(left, right);```
  - 이 경우에는 다음과 같이 메소드 참조를 이용하면 매우 깔끔하게 처리할 수 있다.
  ```Math :: max;```
    
- 메소드 참조는 정적 또는 인스턴스 메소드를 참조할 수 있고, 생성자 참조도 가능하다.
### 정적 메소드와 인스턴스 메소드 참조
- 정적 메소드를 참조할 경우에는 클래스 이름 뒤에 :: 기호를 붙이고 정적 메소드 이름을 기술하면 된다.
```클래스 :: 메소드```
  
- 인스턴스 메소드일 경우에는 먼저 객체를 생성한 다음 참조 변수 뒤에 :: 기호를 붙이고 인스턴스 메소드 이름을 기술하면 된다.
```참조변수 :: 메소드```
  
### 매개 변수의 메소드 참조
- 메소드는 람다식 외부의 클래스 멤버일 수도 있고, 람다식에서 제공되는 매개 변수의 멤버일 수도 있다.
```(a, b) -> { a.instanceMethod(b); }```
  
- 이것을 메소드 참조로 표현하면 다음과 같다.
```클래스 :: instanceMethod```
  - 작성 방법은 정적 메소드 참조와 동일하지만, a의 인스턴스 메소드가 참조되므로 전혀 다른 코드가 실행된다.
  
### 생성자 참조
- 생성자를 참조한다는 것은 객체 생성을 의미한다.
- 단순히 메소드 호출로 구성된 람다식을 메소드 참조로 대치할 수 있듯이, 단순히 객체를 생성하고 리턴하도록 구성된 람다식은 생성자 참조로 대치할 수 있다.

```(a, b) -> { return new 클래스(a, b); }```
  - 이 경우, 생성자 참조로 표현하면 다음과 같다.
  - 생성자가 오버로딩되어 여러 개가 있을 경우, 컴파일러는 함수적 인터페이스의 추상 메소드와 동일한 매개 변수 타입과 개수를 가지고 있는 생성자를 찾아 실행한다.
  
```클래스 :: new```
    