# 제네릭
## 제네릭을 사용하는 이유
- 제네릭은 자바 5부터 새로 추가된 타입이다. 제네릭 타입을 이용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있게 되었다.
제네릭은 컬렉션, 람다식, 스트림, NIO 에서 확실히 이해해두어야 한다. API 도큐먼트를 보면 제네릭 표현이 많이 때문에
  제네릭을 이해하지 못하면 API 도큐먼트를 정확히 이해할 수 없다. 제네릭은 클래스와 인터페이스, 그리고 메소드를 정의할 때
  타입을 파라미터로 사용할 수 있도록 한다. 제네릭을 사용하는 코드는 비제네릭 코드에 비해 다음과 같은 이점을 가지고 있다.
  
## 컴파일 시 강한 타입 체크를 할 수 있다.
- 자바 컴파일러는 코드에서 잘못 사용된 타입 때문에 발생하는 문제점을 제거하기 위해 제네릭 코드에 대해 강한 타입 체크를 한다.
실행 시 타입 에러가 나는 것보다는 컴파일 시에 미리 타입을 강하게 체크해서 사전에 방지하는 것이 좋다.
  
## 타입 변환(casting)을 제거한다.
- 비제네릭 코드는 불필요한 타입 변환을 하기 때문에 프로그램 성능에 악영향을 미친다.

**비제네릭 코드**
```aidl
List list = new ArrayList();
list.add("hello");
String str = (String) list.get(0); // 타입 변환을 해야한다.
```  
**제네릭 코드**
```aidl
List<String> list = new ArrayList<String>();
list.add("hello");
String str = list.get(0); // 타입 변환을 하지 않는다.
```

## 제네릭 타입
- 타입을 파라미터로 가지는 클래스와 인터페이스
```
public class 클래스명<T> {...}
public interface 인터페이스명<T> {...}
```
- 타입 파라미터는 변수명과 동일한 규칙에 따라 작성할 수 있지만, 일반적으로 대문자 알파벳 한 글자로 표현한다.
- 코드에서 타입 변환이 빈번해지면 전체 프로그램 성능에 좋지 못한 결과를 가져올 수 있다.
- 제네릭은 클래스를 설계할 때 구체적인 타입을 명시하지 않고, 타입 파라미터로 대체했다가 실제
클래스가 사용될 때 구체적인 타입을 지정함으로써 타입 변환을 최소화시킨다.
  
## 멀티 타입 파라미터(class<K, V, ...>, interface<K, V, ...>)
- 제네릭 타입은 두 개 이상의 멀티 타입 파라미터를 사용할 수 있는데, 이 경우 각 타입 파라미터를 콤마로 구분한다.
- 자바 7부터 제네릭 타입 파라미터의 중복 기술을 줄이기 위해 다이아몬드 연산자를 제공한다.

**자바 6 이전**

```Product<Tv, String> product = new Product<Tv, String>();```

**자바 7 이후**

```Product<Tv, String> product = new Product<>();```
## 제네릭 메소드(<T, R> R method(T t))
- 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드
- 리턴 타입 앞에 <> 기호를 추가하고 타입 파라미터를 기술한 다음, 리턴 타입과 매개 타입으로 타입 파라미터를 사용한다.

```public <타입파라미터, ...> 리턴타입 메소드명(매개변수, ...) { ... }```
### 제네릭 메소드 호출 방법
- 타입 파라미터의 구체적인 타입을 명시적으로 지정

```리턴타입 변수 = <구체적타입> 메소드명(매개값);```
- 컴파일러가 매개값의 타입을 보고 구체적인 타입을 추정

```리턴타입 변수 = 메소드명(매개값);```
## 제한된 타입 파라미터(<T extends 최상위타입>)
- 타입 파라미터에 지정되는 구체적인 타입을 제한할 필요가 종종 있다. 예를 들어 숫자를 연산하는 제네릭 메소드는
매개값으로 Number 타입 또는 하위 클래스 타입(Byte, Short, Integer, Long, Double)의 인스턴스만 가져야 한다.
- 제한된 타입 파라미터를 선언하려면 타입 파라미터 뒤에 extends 키워드를 붙이고 상위 타입을 명시하면 된다.

```public <T extends 상위타입> 리턴타입 메소드(매개변수, ...) { ... }```
- 타입 파라미터에는 상위 타입이거나 상위 타입의 하위 또는 구현 클래스만 가능하다.
## 와일드카드 타입(<?>, <? extends ...>, <? super ...>)
- 코드에서 ?를 일반적으로 와일도카드라고 부른다. 제네릭 타입을 매개값이나 리턴 타입으로 사용할 때
구체적인 타입 대신에 와일드카드를 다음과 같이 세 가지 형태로 사용할 수 있다.
  - 제네릭타입<?>: Unbounded Wildcards(제한 없음) <- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다.
  - 제네릭타입<? extends 상위타입>: Upper Bounded Wildcards(상위 클래스 제한)
  - 제네릭타입<? super 하위타입>: Lower Bounded Wildcards(하위 클래스 제한) <- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 상위 타입이 올 수 있다.
  
## 제네릭 타입의 상속과 구현
- 제네릭 타입도 다른 타입과 마찬가지로 부모 클래스가 될 수 있다. 

```public class ChildProduct<T, M> extends Product<T, M> { ... }```
- 자식 제네릭 타입은 추가적으로 타입 파라미터를 가질 수 있다.

```public class ChildProduct<T, M, C> extends Product<T, M> { ... }```
